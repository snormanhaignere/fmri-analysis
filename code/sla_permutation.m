function sla_permutation(exp,us,runtype,contrast,runs,volume_or_surface,fla_directory_name,sla_directory_name,varargin)
% Second level analysis that computes a p-value for each voxel based on permutation tests in which the order
% of conditions is shuffled.  See "fla_matlab" for details of permutations.
%
% Modified on 4/9/15 to 
% 
% Last modified by Sam Norman-Haignere on 4/9/15

%% Parameters

% directory containing this script
source_directory = strrep(which('sla_permutation.m'),'sla_permutation.m','');

% directory of useful matlab scripts for dealing with Freesurfer data
addpath([source_directory 'fs/']);

% useful scripts for saving pdfs of figures
addpath([source_directory 'export_fig']);

% default number of samples used to compute p-values
n_smps = 10e3;
if optInputs(varargin, 'n_smps')
    n_smps = varargin{optInputs(varargin, 'n_smps')+1};
end

% number of permutations used in the first-level-analyis
% needs to match the number of permutations in fla_matlab
% permutations are generated by shuffling the order of conditions
if strcmp(volume_or_surface, 'downsampled_surface')
    n_perms = 10000;
else
    n_perms = 100;
end

if optInputs(varargin, 'n_perms')
    n_perms = varargin{optInputs(varargin, 'n_perms')+1};
end

% number of cores to use
% additional cores can greatly speed the analysis
n_cpus = 1;
if optInputs(varargin, 'n_cpus')
    n_cpus = varargin{optInputs(varargin, 'n_cpus')+1};
end

% open a parallel pool if n_cpus > 1
% if n_cpus > 1
%     if exist('parpool','file')
%         delete(gcp('nocreate'));
%         max_cpus = n_cpus;
%         while 1
%             try
%                 parobj = parpool(n_cpus);
%             catch
%                 if n_cpus < round(max_cpus/2)
%                     error('Unable to start a pool with at least %d CPUs\n', n_cpus);
%                 else
%                     n_cpus = n_cpus-1;
%                     sprintf('Reducing requested number of CPUs to %d and trying again\n', n_cpus);
%                 end
%             end
%         end
%     elseif exist('parcluster','file')
%         pclust = parcluster;
%         pclust.NumWorkers = n_cpus;
%         if matlabpool('size') < n_cpus
%             if matlabpool('size') > 0
%                 matlabpool('close');
%             end
%             pclust.matlabpool;
%         end
%     else
%         if matlabpool('size') < n_cpus
%             if matlabpool('size') > 0
%                 matlabpool('close');
%             end
%             matlabpool(n_cpus);
%         end
%     end
% end

%% Analysis

% string used to indicate the runs used in the analysis
if length(runs) > 50
    run_string = ['_' num2str(length(runs)) 'r-' num2str(runs(1)) '-' num2str(runs(end)) '_' DataHash(runs)];
else
    run_string = ['_r' sprintf('%d',runs)];
end

% output files
switch volume_or_surface
    case 'volume'
        
        % directory to save files
        sla_directory = [params('rootdir') exp '/analysis/sla_matlab/usub' num2str(us) '/' runtype run_string '/' sla_directory_name '/'];
        if ~exist(sla_directory,'dir');
            mkdir(sla_directory);
        end
        
        % p-value file
        p_file =  [sla_directory 'pstat_' contrast '_permutation_' num2str(n_smps) '.nii.gz'];
        
        % anatomical
        highres_2mm = [params('rootdir') exp '/analysis/preprocess/usub' num2str(us) '/struct_r1/brain_2mm.nii.gz']; % brain extracted structural image
        if ~exist([sla_directory 'highres_2mm.nii.gz'],'file') || optInputs(varargin, 'overwrite')
            copyfile(highres_2mm, [sla_directory 'highres_2mm.nii.gz'],'f');
        end
        
    case 'surface'
        
        % freesurfer subject id
        subjid = [exp '_us' num2str(us)];
        
        % directory to save files
        if optInputs(varargin, 'monkey')
            sla_directory = [params('rootdir') 'freesurfer/' subjid '/sla_matlab/' runtype run_string '/' sla_directory_name '/'];
        else
            sla_directory = [params('rootdir') 'freesurfer/fsaverage/sla_matlab/' subjid '/' runtype run_string '/' sla_directory_name '/'];
        end
        if ~exist(sla_directory,'dir');
            mkdir(sla_directory);
        end
        
        % surface hemisphere
        if ~optInputs(varargin, 'hemi')
            error('Error in fit_glm: Need to specify hemisphere as optional argument for surface data.m');
        end
        hemi = varargin{optInputs(varargin, 'hemi')+1};
        
        % p-value file
        p_file =  [sla_directory hemi '.pstat_' contrast '_permutation_' num2str(n_smps) '.mgz'];
        
    case 'downsampled_surface'
        
        % freesurfer subject id
        subjid = [exp '_us' num2str(us)];
        
        % directory to save files
        if optInputs(varargin, 'monkey')
            sla_directory = [params('rootdir') 'freesurfer/' subjid '/sla_matlab/' runtype run_string '/' sla_directory_name '_downsampled/'];
        else
            sla_directory = [params('rootdir') 'freesurfer/fsaverage/sla_matlab/' subjid '/' runtype run_string '/' sla_directory_name '_downsampled/'];
        end
        if ~exist(sla_directory,'dir');
            mkdir(sla_directory);
        end
        
        % p-value file
        p_file =  [sla_directory 'pstat_' contrast '_permutation_' num2str(n_smps) '.mat'];
        
    otherwise
        error('Error in sla_matlab: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
end

% check if p-values already computed
if ~exist(p_file,'file') || optInputs(varargin, 'overwrite')
    
    % Loads all the first level data
    fprintf('Reading first level data.\nCan take awhile if there are many runs/permutations.\n'); drawnow;
    tic;
    for i = 1:length(runs)
        % input files
        switch volume_or_surface
            case 'volume'
                
                % directory with results of the first level analysis
                fla_directory = [params('rootdir') exp '/analysis/fla_matlab/usub' num2str(us) '/' runtype '_r' num2str(runs(i)) '/' fla_directory_name '/contrasts/'];
                
                % contrast values and variances for each voxel
                fla_cope_file = [fla_directory 'cope_' contrast '.nii.gz'];
                fla_cope_var_file = [fla_directory 'cope_var_' contrast '.nii.gz'];
                
            case 'surface'
                
                % directory with results of the first level analysis
                if optInputs(varargin, 'monkey')
                    fla_directory = [params('rootdir') 'freesurfer/' subjid '/fla_matlab/' runtype '_r' num2str(runs(i)) '/' fla_directory_name '/contrasts/'];
                else
                    fla_directory = [params('rootdir') 'freesurfer/fsaverage/fla_matlab/' subjid '/' runtype '_r' num2str(runs(i)) '/' fla_directory_name '/contrasts/'];
                end
                
                % contrast values and variances for each voxel
                fla_cope_file = [fla_directory hemi '.cope_' contrast '.mgz'];
                fla_cope_var_file = [fla_directory hemi '.cope_var_' contrast '.mgz'];
                
                % load contrast values and variances for permuted condition orders
                load([fla_directory hemi '.perm_condition_order_' num2str(n_perms) 'smps_' contrast '.mat'],'permuted_cope','permuted_cope_var','nonzero_voxels')
                
            case 'downsampled_surface'
                
                % directory with results of the first level analysis
                if optInputs(varargin, 'monkey')
                    fla_directory = [params('rootdir') 'freesurfer/' subjid '/fla_matlab/' runtype '_r' num2str(runs(i)) '/' fla_directory_name '_downsampled/contrasts/'];
                else
                    fla_directory = [params('rootdir') 'freesurfer/fsaverage/fla_matlab/' subjid '/' runtype '_r' num2str(runs(i)) '/' fla_directory_name '_downsampled/contrasts/'];
                end
                
                % contrast values and variances for each voxel
                fla_cope_file = [fla_directory 'cope_' contrast '.mat'];
                fla_cope_var_file = [fla_directory 'cope_var_' contrast '.mat'];
                
                % load contrast values and variances for permuted condition orders
                load([fla_directory 'perm_condition_order_' num2str(n_perms) 'smps_' contrast '.mat'],'permuted_cope','permuted_cope_var','nonzero_voxels')
                
            otherwise
                error('Error in sla_matlab: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
        end
        
        switch volume_or_surface
            
            case {'volume','surface'}
                % actual contrasts and variances
                x = MRIread(fla_cope_file);
                if i == 1
                    br = x;
                    n_voxels = numel(br.vol);
                    fla_cope = nan(length(runs),n_voxels);
                    fla_cope_var = nan(length(runs),n_voxels);
                    fla_df = nan(length(runs),1);
                end
                fla_cope(i,:) = x.vol(:);
                x = MRIread(fla_cope_var_file);
                fla_cope_var(i,:) = x.vol(:);
                
                % degrees of freedom
                x = load([fla_directory 'df.mat']);
                fla_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_fla_cope = nan(n_perms,length(runs),n_voxels);
                    permuted_fla_cope_var = nan(n_perms,length(runs),n_voxels);
                end
                permuted_fla_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_fla_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            case 'downsampled_surface'
                
                % cope
                load(fla_cope_file);
                if i == 1
                    n_voxels = numel(G.grid_data{1}) + numel(G.grid_data{2});
                    fla_cope = nan(length(runs),n_voxels);
                    fla_cope_var = nan(length(runs),n_voxels);
                    fla_df = nan(length(runs),1);
                end
                fla_cope(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % var cope
                load(fla_cope_var_file);
                fla_cope_var(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % degrees of freedom
                x = load([fla_directory 'df.mat']);
                fla_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_fla_cope = nan(n_perms,length(runs),n_voxels);
                    permuted_fla_cope_var = nan(n_perms,length(runs),n_voxels);
                end
                permuted_fla_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_fla_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            otherwise
                error('Error in sla_matlab: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
        end
    end
    toc;
            
    % t-statistic for each voxel, computed using "fixed-effects" style analysis
    sla_cope = mean(fla_cope,1);
    sla_cope_var = mean(fla_cope_var,1) / length(runs);
    tstat = sla_cope ./ sqrt(sla_cope_var);
        
    fprintf('Selecting voxels without NaN values\n');
    tic;
    voxels_with_no_NaNs = squeeze(all(~isnan(permuted_fla_cope(1,:,:)),2) & all(~isnan(permuted_fla_cope_var(1,:,:)),2)) & ~isnan(tstat)';
    permuted_fla_cope_with_noNaNs = permuted_fla_cope(:,:,voxels_with_no_NaNs);
    permuted_fla_cope_with_noNaNs_var = permuted_fla_cope_var(:,:,voxels_with_no_NaNs);
    tstat_voxels_with_noNaNs = tstat(voxels_with_no_NaNs);
    toc;
    
    % p-values computed by comparing measured t-statistic with null distribution
    % computed in parallel when multiple cores are available
    fprintf('Calculating null distribution and p-statistics\n'); drawnow;
    tic;
    smps = randi(n_perms, [length(runs), n_smps]);
    indices = smps + ((0:length(runs)-1)*n_perms)' * ones(1,n_smps);
    pstat_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    parfor i = 1:length(pstat_voxels_with_no_NaNs)
        permuted_fla_cope_single_voxel = permuted_fla_cope_with_noNaNs(:,:,i);
        permuted_fla_cope_var_single_voxel = permuted_fla_cope_with_noNaNs_var(:,:,i);
        if length(runs)>1
            permuted_sla_cope = mean(permuted_fla_cope_single_voxel(indices),1);
            permuted_sla_cope_var = mean(permuted_fla_cope_var_single_voxel(indices),1)/length(runs);
            permuted_tstat = permuted_sla_cope ./ sqrt(permuted_sla_cope_var);
        else
            permuted_sla_cope = permuted_fla_cope_single_voxel(indices)';
            permuted_sla_cope_var = permuted_fla_cope_var_single_voxel(indices)'/length(runs);
            permuted_tstat = permuted_sla_cope ./ sqrt(permuted_sla_cope_var);
        end
        pstat_voxels_with_no_NaNs(i) = mean(abs(permuted_tstat) > abs(tstat_voxels_with_noNaNs(i))); % two-tailed
    end
    toc;
    
    % clean-up p-statistic vector
    pstat = nan(1,n_voxels);
    pstat(voxels_with_no_NaNs) = pstat_voxels_with_no_NaNs;
    pstat(tstat==0) = 1;
    
    % minimum p-value determined by the number of samples drawn
    pstat(pstat==0) = (1/n_smps);
    
    % PDF and CDF of p-statistic
    figure;
    subplot(1,2,1);
    x = linspace(0,1,100);
    nx = hist(pstat(~isnan(pstat)),x);
    plot(x,nx/sum(nx));
    xlabel('P-Value'); ylabel('Proportion of Voxels');
    title('PDF of Permutation-Based P-values');
    subplot(1,2,2);
    plot(sort(pstat(~isnan(pstat))), cumsum(ones(1,length(pstat(~isnan(pstat)))))/length(pstat(~isnan(pstat))), 'k-','LineWidth',2); hold on;
    plot([0 1],[0 1],'r--','LineWidth',2);
    xlabel('P-Value'); ylabel('Cumulative Proportion of Voxels');
    title('CDF of Permutation-Based P-values');
    % export_fig([sla_directory 'pstat_hist_' contrast '.pdf'],'-pdf','-transparent','-nocrop');
    
    switch volume_or_surface
        
        case {'volume','surface'}
            
            % write p-values to file
            % as signed -log10(p)
            br_pstat = br;
            br_pstat.vol = reshape(sign(tstat(:)) .* -log10(pstat(:)),size(br.vol));
            br_pstat.fspec = p_file;
            MRIwrite(br_pstat, p_file);
            
        case 'downsampled_surface'
            
            G.grid_data{1}(:) = sign(tstat(1:numel(G.grid_data{1}))) .* -log10(pstat(1:numel(G.grid_data{1})));
            G.grid_data{2}(:) = sign(tstat(numel(G.grid_data{1})+1:end)) .* -log10(pstat(numel(G.grid_data{1})+1:end));
            save(p_file, 'G');
            
        otherwise
            error('Error in sla_matlab: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
    end    
end

% optionally plot
if optInputs(varargin, 'sigmap')
    
    % range of p-values to plot
    stat_range = [3,(log10(n_smps)-3)/2,log10(n_smps)];
    if optInputs(varargin, 'stat_range')
        stat_range = varargin{optInputs(varargin, 'stat_range')+1};
    end
    
    switch volume_or_surface
        case 'volume'
            if optInputs(varargin, 'monkey')
                unix_freesurfer_version('5.3.0',['freeview ' highres_2mm ':grayscale=0,150 ' p_file ':colormap=heat:heatscale=' num2str(stat_range(1)) ',' num2str(stat_range(2)) ',' num2str(stat_range(3)) '  &']);
            else
                unix_freesurfer_version('5.3.0',['freeview ' highres_2mm ':grayscale=0,1000 ' p_file ':colormap=heat:heatscale=' num2str(stat_range(1)) ',' num2str(stat_range(2)) ',' num2str(stat_range(3)) '  &']);
            end
        case 'surface'
            %             if optInputs(varargin, 'screenshot')
            %                 screenshot_file = [varargin{optInputs(varargin, 'screenshot')+1} '_' hemi];
            %                 if optInputs(varargin, 'monkey')
            %                     freeview3(subjid,hemi,'overlay',p_file,'overlay_threshold',stat_range,varargin{:},'screenshot',screenshot_file);
            %                 else
            %                     freeview3('fsaverage',hemi,'overlay',p_file,'overlay_threshold',stat_range,varargin{:},'screenshot',screenshot_file);
            %                 end
            %             else
            if optInputs(varargin, 'truncate')
                br = MRIread(p_file);
                br.vol(br.vol<0) = 0;
                br.fspec = strrep(p_file, '.mgz', '_truncate.mgz');
                MRIwrite(br, br.fspec);
                p_file = br.fspec;
            end
            if optInputs(varargin, 'monkey')
                freeview3(subjid,hemi,'overlay',p_file,'overlay_threshold',stat_range,varargin{:});
            else
                freeview3('fsaverage',hemi,'overlay',p_file,'overlay_threshold',stat_range,varargin{:});
            end
            %             end
        case 'downsampled_surface'
            load(p_file);
            figure;
            subplot(1,2,1);
            imagesc(flipud(rot90(G.grid_data{1})));
            title('Right Hemi');
            subplot(1,2,2);
            imagesc(fliplr(flipud(rot90(G.grid_data{2})))); %#ok<FLUDLR>
            title('Left Hemi');
            colorbar;
            
        otherwise
            error('Error in sla_matlab: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
    end
end

