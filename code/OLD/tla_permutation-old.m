function tla_permutation(P,volume_or_surface,tla_directory_name,statistical_test,varargin)

% Example Data (from Amusia experiment)
clear P;
usubs_amusia = [45,49,51,53,55,57,59,71,73,75,171];
for i = 1:11;
    P(i).exp = 'amusia';
    P(i).us = usubs_amusia(i);
    P(i).runtype = 'localizer';
    P(i).runs = 1;
    P(i).contrast = 'harm_vs_noise';
    P(i).lower_level_directory_name = 'smooth300mm_grid_hand-stp-stg_1.5mm';
end
tla_directory_name = 'amusia_group_harm_vs_noise';
volume_or_surface = 'downsampled_surface';
varargin = {};

% scripts directories
source_directory = strrep(which('fla_matlab.m'),'fla_matlab.m','');
addpath(genpath('/software/Freesurfer/5.3.0/matlab'));
addpath([source_directory 'export_fig']);

% default number of samples used to compute p-values
n_smps = 10e3;
if optInputs(varargin, 'n_smps')
    n_smps = varargin{optInputs(varargin, 'n_smps')+1};
end

% number of permutations used in the first-level-analyis
% needs to match the number of permutations in fla_matlab
% permutations are generated by shuffling the order of conditions
n_perms = 100;
if optInputs(varargin, 'n_perms')
    n_perms = varargin{optInputs(varargin, 'n_perms')+1};
end

% output files
switch volume_or_surface
    case 'volume'
        
        error('Need to setup volume analysis');
        
    case 'surface'
        
        error('Need to setup surface analysis');

    case 'downsampled_surface'
        
        tla_directory = [params('rootdir') 'freesurfer/fsaverage/tla_matlab/' tla_directory_name '_downsampled_hash' DataHash(P) '/'];
        if ~exist(tla_directory,'dir');
            mkdir(tla_directory);
        end
        
        z_file =  [tla_directory  'zstat_permutation_' num2str(n_smps) '.mat'];
        p_file =  [tla_directory  'pstat_permutation_' num2str(n_smps) '.mat'];
        
    otherwise
        error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"...');
        
end

if ~exist(p_file,'file') || optInputs(varargin, 'overwrite')
    
    % read in data
    n_subjects = length(P);
    for i = 1:n_subjects
        
        % input files
        switch volume_or_surface
            case 'volume'

                error('Need to setup volume analysis');

            case 'surface'
                
                error('Need to setup surface analysis');

            case 'downsampled_surface'
                
                % subject id
                subjid = [P(i).exp '_us' num2str(P(i).us)];
                
                % first or second level analysis directory to use as input
                if length(P(i).runs) == 1
                    lower_level_directory = [params('rootdir') 'freesurfer/fsaverage/fla_matlab/' subjid '/' P(i).runtype '_r' num2str(P(i).runs) '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                else
                    if length(P(i).runs) > 50
                        run_string = ['_' num2str(length(P(i).runs)) 'r-' num2str(P(i).runs(1)) '-' num2str(P(i).runs(end)) '_' DataHash(P(i).runs)];
                    else
                        run_string = ['_r' sprintf('%d',P(i).runs)];
                    end
                    lower_level_directory = [params('rootdir') 'freesurfer/fsaverage/tla_permutation/' subjid '/' P(i).runtype run_string '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                end
                
                lower_level_cope_file = [lower_level_directory  'cope_' P(i).contrast '.mat'];
                lower_level_cope_var_file = [lower_level_directory 'cope_var_' P(i).contrast '.mat'];
                
                % load contrast values and variances for permuted condition orders
                load([lower_level_directory 'perm_condition_order_' num2str(n_perms) 'smps_' P(i).contrast '.mat'],'permuted_cope','permuted_cope_var','nonzero_voxels')
                
                
            otherwise
                error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
        end
        
        switch volume_or_surface
            
            case {'volume','surface'}
                % actual contrasts and variances
                x = MRIread(lower_level_cope_file);
                if i == 1
                    br = x;
                    n_voxels = numel(br.vol);
                    lower_level_cope = nan(n_subjects,n_voxels);
                    lower_level_cope_var = nan(n_subjects,n_voxels);
                    lower_level_df = nan(n_subjects,1);
                end
                lower_level_cope(i,:) = x.vol(:);
                x = MRIread(lower_level_cope_var_file);
                lower_level_cope_var(i,:) = x.vol(:);
                
                % degrees of freedom
                x = load([lower_level_directory 'df.mat']);
                lower_level_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_lower_level_cope = nan(n_perms,n_subjects,n_voxels);
                    permuted_lower_level_cope_var = nan(n_perms,n_subjects,n_voxels);
                end
                permuted_lower_level_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_lower_level_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            case 'downsampled_surface'
                
                % cope
                load(lower_level_cope_file);
                if i == 1
                    n_voxels = numel(G.grid_data{1}) + numel(G.grid_data{2});
                    lower_level_cope = nan(n_subjects,n_voxels);
                    lower_level_cope_var = nan(n_subjects,n_voxels);
                    lower_level_df = nan(n_subjects,1);
                end
                lower_level_cope(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % var cope
                load(lower_level_cope_var_file);
                lower_level_cope_var(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % degrees of freedom
                x = load([lower_level_directory 'df.mat']);
                lower_level_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_lower_level_cope = nan(n_perms,n_subjects,n_voxels);
                    permuted_lower_level_cope_var = nan(n_perms,n_subjects,n_voxels);
                end
                permuted_lower_level_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_lower_level_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            otherwise
                error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
        end
        
    end
    
    % convert copes to z-statistics
    xi = lower_level_cope ~= 0 & lower_level_cope_var ~=0;
    lower_level_cope(xi) = lower_level_cope(xi) ./ sqrt(lower_level_cope_var(xi));
    lower_level_cope_var(xi) = 1;
    
    % divide permutations by variances
    xi = ~isnan(permuted_lower_level_cope) & ~isnan(permuted_lower_level_cope_var);
    permuted_lower_level_cope(xi) = permuted_lower_level_cope(xi) ./ sqrt(permuted_lower_level_cope_var(xi));
    permuted_lower_level_cope_var(xi) = 1;
        
    % t-statistic for each voxel, computed using "fixed-effects" style analysis
    tla_cope = mean(lower_level_cope);
    tla_cope_var = mean(lower_level_cope_var) / n_subjects;
    tstat = tla_cope ./ sqrt(tla_cope_var);
    
    fprintf('Selecting voxels without NaN values\n');
    tic;
    voxels_with_no_NaNs = squeeze(all(~isnan(permuted_lower_level_cope(1,:,:)),2) & all(~isnan(permuted_lower_level_cope_var(1,:,:)),2)) & ~isnan(tstat)';
    permuted_lower_level_cope_with_noNaNs = permuted_lower_level_cope(:,:,voxels_with_no_NaNs);
    permuted_lower_level_cope_with_noNaNs_var = permuted_lower_level_cope_var(:,:,voxels_with_no_NaNs);
    tstat_voxels_with_noNaNs = tstat(voxels_with_no_NaNs);
    toc;
    
    % p-values computed by comparing measured t-statistic with null distribution
    % computed in parallel when multiple cores are available
    fprintf('Calculating null distribution and p-statistics\n'); drawnow;
    tic;
    smps = randi(n_perms, [n_subjects, n_smps]);
    indices = smps + ((0:n_subjects-1)*n_perms)' * ones(1,n_smps);
    pstat_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    parfor i = 1:length(pstat_voxels_with_no_NaNs)
        permuted_lower_level_cope_single_voxel = permuted_lower_level_cope_with_noNaNs(:,:,i);
        permuted_lower_level_cope_var_single_voxel = permuted_lower_level_cope_with_noNaNs_var(:,:,i);
        permuted_tla_cope = mean(permuted_lower_level_cope_single_voxel(indices));
        permuted_tla_cope_var = mean(permuted_lower_level_cope_var_single_voxel(indices))/n_subjects;
        permuted_tstat = permuted_tla_cope ./ sqrt(permuted_tla_cope_var);
        pstat_voxels_with_no_NaNs(i) = mean(abs(permuted_tstat) > abs(tstat_voxels_with_noNaNs(i))); % two-tailed
    end
    toc;
    
    % clean-up p-statistic vector
    pstat = nan(1,n_voxels);
    pstat(voxels_with_no_NaNs) = pstat_voxels_with_no_NaNs;
    pstat(tstat==0) = 1;
    
    % minimum p-value determined by the number of samples drawn
    pstat(pstat==0) = (1/n_smps);
    
    % PDF and CDF of p-statistic
    figure;
    subplot(1,2,1);
    x = linspace(0,1,100);
    nx = hist(pstat(~isnan(pstat)),x);
    plot(x,nx/sum(nx));
    xlabel('P-Value'); ylabel('Proportion of Voxels');
    title('PDF of Permutation-Based P-values');
    subplot(1,2,2);
    plot(sort(pstat(~isnan(pstat))), cumsum(ones(1,length(pstat(~isnan(pstat)))))/length(pstat(~isnan(pstat))), 'k-','LineWidth',2); hold on;
    plot([0 1],[0 1],'r--','LineWidth',2);
    xlabel('P-Value'); ylabel('Cumulative Proportion of Voxels');
    title('CDF of Permutation-Based P-values');
    % export_fig([sla_directory 'pstat_hist_' contrast '.pdf'],'-pdf','-transparent','-nocrop');
    
    
    switch volume_or_surface
        
        case {'volume','surface'}
            
            % write p-values to file
            % as signed -log10(p)
            br_pstat = br;
            br_pstat.vol = reshape(sign(tstat(:)) .* -log10(pstat(:)),size(br.vol));
            br_pstat.fspec = p_file;
            MRIwrite(br_pstat, p_file);
            
        case 'downsampled_surface'
            
            G.grid_data{1}(:) = sign(tstat(1:numel(G.grid_data{1}))) .* -log10(pstat(1:numel(G.grid_data{1})));
            G.grid_data{2}(:) = sign(tstat(numel(G.grid_data{1})+1:end)) .* -log10(pstat(numel(G.grid_data{1})+1:end));
            save(p_file, 'G');
            
        otherwise
            error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
    end    
    
    clusters = bwconncomp(G.grid_data{1}>3,4);
    
        
end

smps = randi(n_perms, [n_subjects, n_smps]);
indices = smps + ((0:n_subjects-1)*n_perms)' * ones(1,n_smps);

sampled_cope_map = nan(n_subjects, sum(voxels_with_no_NaNs));
sampled_cope_map_var = nan(n_subjects, sum(voxels_with_no_NaNs));
sampled_tmap = nan(1, n_voxels);
rh_grid = nan(size(G.grid_data{1}));
lh_grid = nan(size(G.grid_data{2}));
n_clusters = nan(1,n_smps);
max_cluster_size = zeros(1,n_smps);
for i = 1:n_smps
    
    for j = 1:n_subjects
        sampled_cope_map(j,:) = permuted_lower_level_cope_with_noNaNs( smps(j,i), j, :);
        sampled_cope_map_var(j,:) = permuted_lower_level_cope_with_noNaNs_var( smps(j,i), j, :);
    end
    
    sampled_tmap(voxels_with_no_NaNs) = mean(sampled_cope_map) ./ sqrt(mean(sampled_cope_map_var)/n_subjects);
    rh_grid(:) = sampled_tmap(1:numel(rh_grid));
    lh_grid(:) = sampled_tmap(numel(rh_grid)+1:end);

    comp_rh = bwconncomp(rh_grid>10, 4);
    comp_lh = bwconncomp(lh_grid>10, 4);
    n_clusters(i) = comp_rh.NumObjects + comp_lh.NumObjects;
    
    for j = 1:comp_rh.NumObjects
        max_cluster_size(i) = max(max_cluster_size(i), length(comp_rh.PixelIdxList{j}));
    end
    
end

rh_grid(:) = tstat(1:numel(rh_grid));
lh_grid(:) = tstat(numel(rh_grid)+1:end);


    % p-values computed by comparing measured t-statistic with null distribution
    % computed in parallel when multiple cores are available
    fprintf('Calculating null distribution and p-statistics\n'); drawnow;
    tic;
    smps = randi(n_perms, [n_subjects, n_smps]);
    indices = smps + ((0:n_subjects-1)*n_perms)' * ones(1,n_smps);
    pstat_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    parfor i = 1:length(pstat_voxels_with_no_NaNs)
        permuted_lower_level_cope_single_voxel = permuted_lower_level_cope_with_noNaNs(:,:,i);
        permuted_lower_level_cope_var_single_voxel = permuted_lower_level_cope_with_noNaNs_var(:,:,i);
        permuted_tla_cope = mean(permuted_lower_level_cope_single_voxel(indices));
        permuted_tla_cope_var = mean(permuted_lower_level_cope_var_single_voxel(indices))/n_subjects;
        permuted_tstat = permuted_tla_cope ./ sqrt(permuted_tla_cope_var);
        pstat_voxels_with_no_NaNs(i) = mean(abs(permuted_tstat) > abs(tstat_voxels_with_noNaNs(i))); % two-tailed
    end
    toc;


stat_range = [3,4.5,6];
if optInputs(varargin, 'stat_range')
    stat_range = varargin{optInputs(varargin, 'stat_range')+1};
end

stat_file = p_file;
if optInputs(varargin, 'tstat')
    stat_file = t_file;
end

if optInputs(varargin, 'sigmap')
    switch volume_or_surface
        case 'volume'
            if optInputs(varargin, 'monkey')
                unix_freesurfer_version('5.3.0',['freeview ' highres_2mm ':grayscale=0,150 ' stat_file ':colormap=heat:heatscale=' num2str(stat_range(1)) ',' num2str(stat_range(2)) ',' num2str(stat_range(3)) '  &']);
            else
                unix_freesurfer_version('5.3.0',['freeview ' highres_2mm ':grayscale=0,1000 ' stat_file ':colormap=heat:heatscale=' num2str(stat_range(1)) ',' num2str(stat_range(2)) ',' num2str(stat_range(3)) '  &']);
            end
        case 'surface'
            if optInputs(varargin, 'truncate')
                br = MRIread(stat_file);
                br.vol(br.vol<0) = 0;
                br.fspec = strrep(stat_file, '.mgz', '_truncate.mgz');
                MRIwrite(br, br.fspec);
                stat_file = br.fspec;
            end
            subjid = [exp '_us' num2str(us)];
            if optInputs(varargin, 'monkey')
                freeview3(subjid,hemi,'overlay',stat_file,'overlay_threshold',stat_range,varargin{:});
            else
                freeview3('fsaverage',hemi,'overlay',stat_file,'overlay_threshold',stat_range,varargin{:});
            end
        case 'downsampled_surface'
            load(p_file);
            figure;
            subplot(1,2,1);
            imagesc(flipud(rot90(G.grid_data{1})));
            title('Right Hemi');
            subplot(1,2,2);
            imagesc(fliplr(flipud(rot90(G.grid_data{2})))); %#ok<FLUDLR>
            title('Left Hemi');
            colorbar;
            
        otherwise
            error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
    end
end

