function [mat_file_with_all_useful_statistics, ...
    p_gaussfit_rh_inflated_file, p_gaussfit_lh_inflated_file, p_gaussfit_file]...
    = tla_permutation_voxelwise_stats(P,volume_or_surface,tla_directory_name,varargin)

% function mat_file_with_all_useful_statistics = tla_permutation_voxelwise_stats(P,volume_or_surface,tla_directory_name,varargin)
% 
% Calculates group voxelwise statistics using permuted condition orders. Relies on regression
% analyses run by fla_matlab. Voxelwise statistics can be corrected for multiple comparisons
% usinc cluster correction (tla_permutation_clustcorr) or fdr correction
% (tla_permutation_clustcorr).
% 
% Subset of the function tla_permutation/tla_permutation2, separated out for clarity.
% 
% Example Data (from Amusia experiment)
% clear P;
% usubs_amusia  = [45,49,51,53,55,57,59,71,73,75,171]';
% tla_directory_name = 'amusia_group_harm_vs_noise_5mm';
% for i = 1:11;
%     P(i).exp = 'amusia'; %#ok<*SAGROW>
%     P(i).us = usubs_amusia(i);
%     P(i).runtype = 'localizer';
%     P(i).runs = 1;
%     P(i).contrast = 'harm_vs_noise';
%     % P(i).lower_level_directory_name = 'smooth300mm_grid_hand-stp-stg_1.5mm';
%     P(i).lower_level_directory_name = 'smooth500mm_grid_hand-stp-stg_1.5mm_10whitematterPCs';
% end
% volume_or_surface = 'downsampled_surface';
% varargin = {'n_smps',10e3,'sigmap'};
% tla_permutation_voxelwise_stats(P,volume_or_surface,tla_directory_name,varargin{:});
% 
% Last modified by Sam Norman-Haignere on 15-06-18

% default number of samples used to compute p-values
n_smps = 10e3;
if optInputs(varargin, 'n_smps')
    n_smps = varargin{optInputs(varargin, 'n_smps')+1};
end

% number of permutations used in the first-level-analyis
% needs to match the number of permutations in fla_matlab
% permutations are generated by shuffling the order of conditions
n_perms = 100;
if optInputs(varargin, 'n_perms')
    n_perms = varargin{optInputs(varargin, 'n_perms')+1};
end

% p-value threshold
voxel_pthresh = 3;
if optInputs(varargin, 'voxel_pthresh')
    voxel_pthresh = varargin{optInputs(varargin, 'voxel_pthresh') + 1};
end

% whether or not to plot summary stats
plot_stats = true;
if optInputs(varargin, 'no_stat_plots')
    plot_stats = false;
end

% -- univariate permutation test --

% output files
switch volume_or_surface
    case 'volume'
        
        % directory to save results to
        tla_directory = [params('rootdir') 'tla_matlab/' tla_directory_name ...
            '_downsampled_hash' DataHash(P) '/'];
        if ~exist(tla_directory, 'dir'); mkdir(tla_directory);  end
        
        % zstat
        z_file = [tla_directory ...
            'zstat_permutation_' num2str(n_smps) '.nii.gz'];
        
        % zstat based on gaussian fit to the null
        z_gaussfit_file = [tla_directory ...
            'zstat_permutation_gaussfit_' num2str(n_smps) '.nii.gz'];

        % p-values based on counting the number of times the null
        % distribution exceeds the measured value
        p_file =  [tla_directory ...
            'pstat_permutation_' num2str(n_smps) '.nii.gz'];
        
        % p-values based on gaussian fits to the null distribution
        p_gaussfit_file = [tla_directory ...
            'pstat_permutation_' num2str(n_smps) '_gaussfit.nii.gz'];
        
        mat_file_with_all_useful_statistics =  [tla_directory  'all_statistics_' num2str(n_smps) '.mat']; 
                
        p_rh_inflated_file = [];
        p_lh_inflated_file = [];
        p_gaussfit_rh_inflated_file = [];
        p_gaussfit_lh_inflated_file = [];
        
    case 'surface'
        
        error('Need to setup surface analysis');
        
    case 'downsampled_surface'
        
        % freesurfer subject id
        if optInputs(varargin, 'monkey')
            subjid = [P(1).exp '_us' num2str(P(1).us)];
            tla_directory = [params('rootdir') 'freesurfer/' subjid      '/tla_matlab/' tla_directory_name '_downsampled_hash' DataHash(P) '/'];
        else
            tla_directory = [params('rootdir') 'freesurfer/' 'fsaverage' '/tla_matlab/' tla_directory_name '_downsampled_hash' DataHash(P) '/'];
        end
        
        if ~exist(tla_directory, 'dir');
            mkdir(tla_directory);
        end
        
        % zstat
        z_file =  [tla_directory  'zstat_permutation_' num2str(n_smps) '.mat'];
        
        % zstat based on gaussian fit to the null
        z_gaussfit_file =  [tla_directory  'zstat_permutation_gaussfit_' num2str(n_smps) '.mat'];

        % p-values based on counting the number of times the null
        % distribution exceeds the measured value
        p_file =  [tla_directory  'pstat_permutation_' num2str(n_smps) '.mat'];
        p_rh_inflated_file =  [tla_directory  'rh.pstat_permutation_' num2str(n_smps) '.mgz'];
        p_lh_inflated_file =  [tla_directory  'lh.pstat_permutation_' num2str(n_smps) '.mgz'];
        
        % p-values based on gaussian fits to the null distribution
        p_gaussfit_file =  [tla_directory  'pstat_permutation_' num2str(n_smps) '_gaussfit.mat'];
        p_gaussfit_rh_inflated_file =  [tla_directory  'rh.pstat_permutation_' num2str(n_smps) '_gaussfit.mgz'];
        p_gaussfit_lh_inflated_file =  [tla_directory  'lh.pstat_permutation_' num2str(n_smps) '_gaussfit.mgz'];
        
        mat_file_with_all_useful_statistics =  [tla_directory  'all_statistics_' num2str(n_smps) '.mat'];
        
    otherwise
        error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"...');
        
end

files_to_create = {...
    z_file, z_gaussfit_file, p_file, p_gaussfit_file,...
    mat_file_with_all_useful_statistics};
all_files_exist = true;
for i = 1:length(files_to_create);
    if ~exist(files_to_create{i},'file');
        all_files_exist = false;
    end
end

if ~all_files_exist || optInputs(varargin, 'overwrite')
    
    % scripts directories
    source_directory = strrep(which('fla_matlab.m'),'fla_matlab.m','');
    addpath(genpath('/software/Freesurfer/5.3.0/matlab'));
    addpath([source_directory 'export_fig_v2']);
    
    % read in data
    n_subjects = length(P);
    for i = 1:n_subjects
        
        % input files
        switch volume_or_surface
            case 'volume'
                
                % first or second level analysis directory to use as input
                if length(P(i).runs) == 1
                    lower_level_directory = [...
                        params('rootdir')  P(i).exp '/analysis/fla_matlab' ...
                        '/usub' num2str(P(i).us) '/'...
                        P(i).runtype '_r' num2str(P(i).runs) ...
                        '/' P(i).lower_level_directory_name '/contrasts/'];
                else
                    error('Needs to be coded to take second level directories');
                end
                
                lower_level_cope_file = ...
                    [lower_level_directory 'cope_' P(i).contrast '.nii.gz'];
                lower_level_cope_var_file = ...
                    [lower_level_directory 'cope_var_' P(i).contrast '.nii.gz'];
                
                % load contrast values and variances for permuted condition orders
                load([lower_level_directory 'perm_condition_order_' ...
                    num2str(n_perms) 'smps_' P(i).contrast '.mat'],...
                    'permuted_cope','permuted_cope_var','nonzero_voxels');
                                
            case 'surface'
                
                error('Need to setup surface analysis');
                
            case 'downsampled_surface'
                
                % subject id
                subjid = [P(i).exp '_us' num2str(P(i).us)];
                
                % first or second level analysis directory to use as input
                if length(P(i).runs) == 1
                    
                    % directory with results of the first level analysis
                    if optInputs(varargin, 'monkey')
                        lower_level_directory = [params('rootdir') 'freesurfer/' subjid '/fla_matlab/' P(i).runtype '_r' num2str(P(i).runs) '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                    else
                        lower_level_directory = [params('rootdir') 'freesurfer/fsaverage/fla_matlab/' subjid '/' P(i).runtype '_r' num2str(P(i).runs) '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                    end
                    
                else
                    
                    error('Needs to be coded to take second level directories');
                    %                 else
                    %                     if length(P(i).runs) > 50
                    %                         run_string = ['_' num2str(length(P(i).runs)) 'r-' num2str(P(i).runs(1)) '-' num2str(P(i).runs(end)) '_' DataHash(P(i).runs)];
                    %                     else
                    %                         run_string = ['_r' sprintf('%d',P(i).runs)];
                    %                     end
                    %                     lower_level_directory = [params('rootdir') 'freesurfer/fsaverage/tla_permutation/' subjid '/' P(i).runtype run_string '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                end
                
                lower_level_cope_file = [lower_level_directory  'cope_' P(i).contrast '.mat'];
                lower_level_cope_var_file = [lower_level_directory 'cope_var_' P(i).contrast '.mat'];
                
                % load contrast values and variances for permuted condition orders
                load([lower_level_directory 'perm_condition_order_' num2str(n_perms) 'smps_' P(i).contrast '.mat'],'permuted_cope','permuted_cope_var','nonzero_voxels')
                
            otherwise
                error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
        end
        
        switch volume_or_surface
            
            case {'volume','surface'}
                
                % actual contrasts and variances
                x = MRIread(lower_level_cope_file);
                if i == 1
                    br = x;
                    n_voxels = numel(x.vol);
                    lower_level_cope = nan(n_subjects,n_voxels);
                    lower_level_cope_var = nan(n_subjects,n_voxels);
                    lower_level_df = nan(n_subjects,1);
                end
                lower_level_cope(i,:) = x.vol(:);
                x = MRIread(lower_level_cope_var_file);
                lower_level_cope_var(i,:) = x.vol(:);
                
                % degrees of freedom
                x = load([lower_level_directory 'df.mat']);
                lower_level_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_lower_level_cope = nan(n_perms,n_subjects,n_voxels);
                    permuted_lower_level_cope_var = nan(n_perms,n_subjects,n_voxels);
                end
                permuted_lower_level_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_lower_level_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            case 'downsampled_surface'
                
                % cope
                load(lower_level_cope_file);
                if i == 1
                    n_voxels = numel(G.grid_data{1}) + numel(G.grid_data{2});
                    lower_level_cope = nan(n_subjects,n_voxels);
                    lower_level_cope_var = nan(n_subjects,n_voxels);
                    lower_level_df = nan(n_subjects,1);
                end
                lower_level_cope(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % var cope
                load(lower_level_cope_var_file);
                lower_level_cope_var(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % degrees of freedom
                x = load([lower_level_directory 'df.mat']);
                lower_level_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_lower_level_cope = nan(n_perms,n_subjects,n_voxels);
                    permuted_lower_level_cope_var = nan(n_perms,n_subjects,n_voxels);
                end
                permuted_lower_level_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_lower_level_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            otherwise
                error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
        end
        
    end
    
    % convert copes to z-statistics
    lower_level_z = nan(size(lower_level_cope));
    xi = lower_level_cope ~= 0 & lower_level_cope_var ~=0;
    lower_level_z(xi) = lower_level_cope(xi) ./ sqrt(lower_level_cope_var(xi));
    
    % divide permutations by variances
    permuted_lower_level_z = nan(size(permuted_lower_level_cope));
    xi = ~isnan(permuted_lower_level_cope) & ~isnan(permuted_lower_level_cope_var);
    permuted_lower_level_z(xi) = permuted_lower_level_cope(xi) ./ sqrt(permuted_lower_level_cope_var(xi));
    
    % third-level, z-statistic
    zstat = mean(lower_level_z);
    
    fprintf('Selecting voxels without NaN values\n');
    tic;
    voxels_with_no_NaNs = squeeze(all(~isnan(permuted_lower_level_z(1,:,:)),2)) & ~isnan(zstat)';
    permuted_lower_level_z_with_noNaNs = permuted_lower_level_z(:,:,voxels_with_no_NaNs);
    tla_z_voxels_with_noNaNs = zstat(voxels_with_no_NaNs);
    toc;
        
    % p-values computed by comparing measured t-statistic with null distribution
    % computed in parallel when multiple cores are available
    fprintf('Calculating null distribution and p-statistics\n'); drawnow;
    tic;
    smps = randi(n_perms, [n_subjects, n_smps]);
    indices = smps + ((0:n_subjects-1)*n_perms)' * ones(1,n_smps);
    pstat_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    pstat_gaussfit_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    zstat_gaussfit_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    nullmean_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    nullstd_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    for i = 1:length(pstat_voxels_with_no_NaNs)
        
        % permuted z values for a single voxel
        % -> permutations x subject
        permuted_lower_level_z_single_voxel = permuted_lower_level_z_with_noNaNs(:,:,i);
        
        % average across permuted maps of different subjects
        % -> 1 x permutation
        permuted_tla_z = mean(permuted_lower_level_z_single_voxel(indices));
        
        % mean and standard deviation of the null
        nullmean_voxels_with_no_NaNs(i) = mean(permuted_tla_z);
        nullstd_voxels_with_no_NaNs(i) = std(permuted_tla_z);
        
        % z-statistic for unpermuted regressors with respect to the mean
        % and standard deviation of the null
        zstat_gaussfit_voxels_with_no_NaNs(i) = (tla_z_voxels_with_noNaNs(i) - nullmean_voxels_with_no_NaNs(i)) ./ nullstd_voxels_with_no_NaNs(i);
        
        % convert z-statistic to p value
        pstat_gaussfit_voxels_with_no_NaNs(i) = 2*normcdf(-abs(zstat_gaussfit_voxels_with_no_NaNs(i)), 0, 1);
        
        % measure empirical p-value via counts
        pstat_voxels_with_no_NaNs(i) = mean(abs(permuted_tla_z) > abs(tla_z_voxels_with_noNaNs(i))); % two-tailed
    end
    toc;
    
    % clean-up p-statistic vector
    pstat = nan(1,n_voxels);
    pstat(voxels_with_no_NaNs) = pstat_voxels_with_no_NaNs;
    pstat_gaussfit = nan(1,n_voxels);
    pstat_gaussfit(voxels_with_no_NaNs) = pstat_gaussfit_voxels_with_no_NaNs;
    zstat_gaussfit = nan(1,n_voxels);
    zstat_gaussfit(voxels_with_no_NaNs) = zstat_gaussfit_voxels_with_no_NaNs;
    nullmean = nan(1,n_voxels);
    nullmean(voxels_with_no_NaNs) = nullmean_voxels_with_no_NaNs;
    nullstd = nan(1,n_voxels);
    nullstd(voxels_with_no_NaNs) = nullstd_voxels_with_no_NaNs;
    
    % minimum p-value determined by the number of samples drawn
    pstat(pstat==0) = (1/n_smps);
    pstat_gaussfit(pstat_gaussfit==0) = min(pstat_gaussfit(pstat_gaussfit>0));
    
    % PDF and CDF of p-statistic
    
    if plot_stats
    figure;
    subplot(1,2,1);
    x = linspace(0,1,100);
    nx = hist(pstat(~isnan(pstat)),x);
    plot(x,nx/sum(nx));
    xlabel('P-Value'); ylabel('Proportion of Voxels');
    title('PDF of Permutation-Based P-values');
    subplot(1,2,2);
    plot(sort(pstat(~isnan(pstat))), cumsum(ones(1,length(pstat(~isnan(pstat)))))/length(pstat(~isnan(pstat))), 'k-','LineWidth',2); hold on;
    plot([0 1],[0 1],'r--','LineWidth',2);
    xlabel('P-Value'); ylabel('Cumulative Proportion of Voxels');
    title('CDF of Permutation-Based P-values');
    try export_fig([tla_directory 'pstat_hist.pdf'],'-pdf','-transparent','-nocrop'); catch; end
    end
    
    switch volume_or_surface
        
        case {'volume','surface'}

            br.vol(:) = sign(zstat) .* -log10(pstat);
            br.fspec = p_file;
            MRIwrite(br, p_file);
            
            br.vol(:) = zstat;
            br.fspec = z_file;
            MRIwrite(br, z_file);
            
            br.vol(:) = sign(zstat_gaussfit) .* -log10(pstat_gaussfit);
            br.fspec = p_gaussfit_file;
            MRIwrite(br, p_gaussfit_file);
            
            br.vol(:) = zstat_gaussfit;
            br.fspec = z_gaussfit_file;
            MRIwrite(br, z_gaussfit_file);
            
        case 'downsampled_surface'
            
            % p-map file
            G.grid_data{1}(:) = sign(zstat(1:numel(G.grid_data{1}))) .* -log10(pstat(1:numel(G.grid_data{1})));
            G.grid_data{2}(:) = sign(zstat(numel(G.grid_data{1})+1:end)) .* -log10(pstat(numel(G.grid_data{1})+1:end));
            save(p_file, 'G');
            Gpstat = G;
                        
            % z-stat file
            G.grid_data{1}(:) = zstat(1:numel(G.grid_data{1}));
            G.grid_data{2}(:) = zstat(numel(G.grid_data{1})+1:end);
            save(z_file, 'G');
            
            % p-map based on gaussian fits file
            G.grid_data{1}(:) = sign(zstat_gaussfit(1:numel(G.grid_data{1}))) .* -log10(pstat_gaussfit(1:numel(G.grid_data{1})));
            G.grid_data{2}(:) = sign(zstat_gaussfit(numel(G.grid_data{1})+1:end)) .* -log10(pstat_gaussfit(numel(G.grid_data{1})+1:end));
            save(p_gaussfit_file, 'G');
            Gpstat_gaussfit = G;
                        
            % z-stat based on gaussian fits
            G.grid_data{1}(:) = zstat_gaussfit(1:numel(G.grid_data{1}));
            G.grid_data{2}(:) = zstat_gaussfit(numel(G.grid_data{1})+1:end);
            save(z_gaussfit_file, 'G');
            
            
            % p-map resampled to the inflated fsaverage brain
            hemis = {'rh','lh'};
            for j = 1:2
                
                if optInputs(varargin, 'monkey')
                    nsurfpts_monkeys = [157 143689 143035; 158 134082 135694; 170 83802 83075];
                    xi = ismember(nsurfpts_monkeys(:,1), P(1).us);
                    nsurfpts = nsurfpts_monkeys(xi,j+1);
                else
                    % number of surface points on the fsaverage template brain
                    nsurfpts = 163842;
                end
                
                p_inflated = nan(1, nsurfpts);
                p_gaussfit_inflated = nan(1, nsurfpts);
                p_inflated(G.vi{j}+1) = interp2(Gpstat.grid_x{j},Gpstat.grid_y{j} ,Gpstat.grid_data{j}, Gpstat.vras{j}(:,1), Gpstat.vras{j}(:,2), 'linear');
                p_gaussfit_inflated(G.vi{j}+1) = interp2(Gpstat_gaussfit.grid_x{j}, Gpstat_gaussfit.grid_y{j}, Gpstat_gaussfit.grid_data{j}, Gpstat_gaussfit.vras{j}(:,1), Gpstat_gaussfit.vras{j}(:,2),'linear');
                switch hemis{j}
                    case 'rh'
                        MRIwrite_surface(p_inflated, p_rh_inflated_file, 'rh');
                        MRIwrite_surface(p_gaussfit_inflated, p_gaussfit_rh_inflated_file, 'rh');
                    case 'lh'
                        MRIwrite_surface(p_inflated, p_lh_inflated_file, 'lh');
                        MRIwrite_surface(p_gaussfit_inflated, p_gaussfit_lh_inflated_file, 'lh');
                end
            end
            
        otherwise
            error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
    end
    
    save(mat_file_with_all_useful_statistics, '-v7.3', 'zstat', 'pstat', 'pstat_gaussfit', 'zstat_gaussfit', 'nullmean', 'nullstd', 'permuted_lower_level_z_with_noNaNs', 'voxels_with_no_NaNs', 'nullmean_voxels_with_no_NaNs', 'nullstd_voxels_with_no_NaNs', 'smps', 'lower_level_z')
    
end    
    
if plot_stats
    
    load(mat_file_with_all_useful_statistics, 'zstat', 'pstat', 'pstat_gaussfit', 'zstat_gaussfit', 'nullmean', 'nullstd', 'permuted_lower_level_z_with_noNaNs', 'voxels_with_no_NaNs', 'nullmean_voxels_with_no_NaNs', 'nullstd_voxels_with_no_NaNs', 'smps')
    
    % p-statistic vs z-statistic
    % useful to pick cluster threshold
    figure;
    plot(sign(zstat_gaussfit(voxels_with_no_NaNs)) .* -log10(pstat_gaussfit(voxels_with_no_NaNs)), zstat_gaussfit(voxels_with_no_NaNs), 'ko');
    ylabel('z-statistic'); xlabel('p-statistic (-log10[p])');
    xL = xlim;
    hold on; h = plot(xL, voxel_pthresh*[1 1], 'r--');
    box off;
    legend(h, 'P-value Threshold', 'Location', 'Best');
    try export_fig([tla_directory 'z-vs-p.pdf'],'-pdf','-transparent'); catch; end
    
    % compare p-statistics based on gaussian fits with the p-statistics based
    % on counts
    figure;
    log10pstat = sign(zstat(voxels_with_no_NaNs)) .* -log10(pstat(voxels_with_no_NaNs));
    log10pstat_gaussfit = sign(zstat_gaussfit(voxels_with_no_NaNs)) .* -log10(pstat_gaussfit(voxels_with_no_NaNs));
    plot(log10pstat, log10pstat_gaussfit, 'ko');
    xlabel('p-statistic (-log10[p])'); ylabel('gaussian-approximated p-statistic (-log10[p])');
    bounds = [min(log10pstat_gaussfit(:)), max(log10pstat_gaussfit(:))];
    xlim(bounds); ylim(bounds);
    x = linspace(bounds(1),bounds(2),100);
    hold on; plot(x,x,'r--');
    box off;
    %     try
    %         export_fig([tla_directory 'p-gaussfit-vs-p-count.pdf'],'-pdf','-transparent');
    %     catch
    %     end
end

% -- plot statistic --
if optInputs(varargin, 'sigmap')
    switch volume_or_surface
        case 'volume'
            
            error('Need to setup volume analysis');
            
        case 'surface'
            
            error('Need to setup surface analysis');
            
        case 'downsampled_surface'
            
            % plot p map on the downsampled surface
            load(p_gaussfit_file);
            figure;
            subplot(1,2,1);
            imagesc(flipud(rot90(G.grid_data{1})), [-6 6]);
            title('Right Hemi');
            subplot(1,2,2);
            imagesc(fliplr(flipud(rot90(G.grid_data{2}))), [-6 6]); %#ok<FLUDLR>
            title('Left Hemi');
            colorbar;
            
            bounds = [voxel_pthresh, 6];
            midpoint = bounds(1) + 0.5*(bounds(2) - bounds(1));
            overlay_threshold = [bounds(1), midpoint, bounds(2)];
            
            if optInputs(varargin, 'monkey')
                freeview3(subjid,'rh','overlay',p_gaussfit_rh_inflated_file, 'overlay_threshold', overlay_threshold);
                freeview3(subjid,'lh','overlay',p_gaussfit_lh_inflated_file, 'overlay_threshold', overlay_threshold);
            else
                freeview3('fsaverage','rh','overlay',p_gaussfit_rh_inflated_file, 'overlay_threshold', overlay_threshold);
                freeview3('fsaverage','lh','overlay',p_gaussfit_lh_inflated_file, 'overlay_threshold', overlay_threshold);
            end
                        
            % plot map on the inflated fsaverage brain
            
            p_gaussfit_rh_inflated_file
            p_gaussfit_lh_inflated_file

            
        otherwise
            error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
    end
end
