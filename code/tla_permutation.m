function tla_directory = tla_permutation(P,volume_or_surface,tla_directory_name,varargin)

% Example Data (from Amusia experiment)
% clear P;
% usubs_amusia = [45,49,51,53,55,57,59,71,73,75,171];
% tla_directory_name = 'amusia_group_harm_vs_noise';
% for i = 1:11;
%     P(i).exp = 'amusia';
%     P(i).us = usubs_control(i);
%     P(i).runtype = 'localizer';
%     P(i).runs = 1;
%     P(i).contrast = 'harm_vs_noise';
%     P(i).lower_level_directory_name = 'smooth300mm_grid_hand-stp-stg_1.5mm';
% end
% volume_or_surface = 'downsampled_surface';
% varargin = {'cluster-correction','overwrite','sigmap'};

% scripts directories
source_directory = strrep(which('fla_matlab.m'),'fla_matlab.m','');
addpath(genpath('/software/Freesurfer/5.3.0/matlab'));
addpath([source_directory 'export_fig']);

% default number of samples used to compute p-values
n_smps = 10e3;
if optInputs(varargin, 'n_smps')
    n_smps = varargin{optInputs(varargin, 'n_smps')+1};
end

% number of permutations used in the first-level-analyis
% needs to match the number of permutations in fla_matlab
% permutations are generated by shuffling the order of conditions
n_perms = 100;
if optInputs(varargin, 'n_perms')
    n_perms = varargin{optInputs(varargin, 'n_perms')+1};
end

% number of surface points on the fsaverage template brain
nsurfpts = 163842;

% -- univariate permutation test --

% output files
switch volume_or_surface
    case 'volume'
        
        error('Need to setup volume analysis');
        
    case 'surface'
        
        error('Need to setup surface analysis');
        
    case 'downsampled_surface'
        
        
        % freesurfer subject id
        if optInputs(varargin, 'monkey')
            subjid = [P(1).exp '_us' num2str(P(1).us)];
            tla_directory = [params('rootdir') 'freesurfer/' subjid      '/tla_matlab/' tla_directory_name '_downsampled_hash' DataHash(P) '/'];
        else
            tla_directory = [params('rootdir') 'freesurfer/' 'fsaverage' '/tla_matlab/' tla_directory_name '_downsampled_hash' DataHash(P) '/'];
        end
        
        if ~exist(tla_directory,'dir');
            mkdir(tla_directory);
        end
        
        % zstat
        z_file =  [tla_directory  'zstat_permutation_' num2str(n_smps) '.mat'];
        
        % zstat based on gaussian fit to the null
        z_gaussfit_file =  [tla_directory  'zstat_permutation_' num2str(n_smps) '.mat'];

        % p-values based on counting the number of times the null
        % distribution exceeds the measured value
        p_file =  [tla_directory  'pstat_permutation_' num2str(n_smps) '.mat'];
        p_rh_inflated_file =  [tla_directory  'rh.pstat_permutation_' num2str(n_smps) '.mgz'];
        p_lh_inflated_file =  [tla_directory  'lh.pstat_permutation_' num2str(n_smps) '.mgz'];
        
        % p-values based on gaussian fits to the null distribution
        p_gaussfit_file =  [tla_directory  'pstat_permutation_' num2str(n_smps) '_gaussfit.mat'];
        p_gaussfit_rh_inflated_file =  [tla_directory  'rh.pstat_permutation_' num2str(n_smps) '_gaussfit.mgz'];
        p_gaussfit_lh_inflated_file =  [tla_directory  'lh.pstat_permutation_' num2str(n_smps) '_gaussfit.mgz'];
        
        mat_file_with_all_useful_statistics =  [tla_directory  'all_statistics_' num2str(n_smps) '.mat'];
        
    otherwise
        error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"...');
        
end

files_to_create = {z_file, z_gaussfit_file, p_file, p_rh_inflated_file, p_lh_inflated_file, p_gaussfit_file, p_gaussfit_rh_inflated_file, p_gaussfit_lh_inflated_file, mat_file_with_all_useful_statistics};
all_files_exist = true;
for i = 1:length(files_to_create);
    if ~exist(files_to_create{i},'file');
        all_files_exist = false;
    end
end

if ~all_files_exist || optInputs(varargin, 'overwrite')
    
    % read in data
    n_subjects = length(P);
    for i = 1:n_subjects
        
        % input files
        switch volume_or_surface
            case 'volume'
                
                error('Need to setup volume analysis');
                
            case 'surface'
                
                error('Need to setup surface analysis');
                
            case 'downsampled_surface'
                
                % subject id
                subjid = [P(i).exp '_us' num2str(P(i).us)];
                
                % first or second level analysis directory to use as input
                if length(P(i).runs) == 1
                    
                    % directory with results of the first level analysis
                    if optInputs(varargin, 'monkey')
                        lower_level_directory = [params('rootdir') 'freesurfer/' subjid '/fla_matlab/' P(i).runtype '_r' num2str(P(i).runs) '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                    else
                        lower_level_directory = [params('rootdir') 'freesurfer/fsaverage/fla_matlab/' subjid '/' P(i).runtype '_r' num2str(P(i).runs) '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                    end
                    
                else
                    
                    error('Needs to be coded to take second level directories');
                    %                 else
                    %                     if length(P(i).runs) > 50
                    %                         run_string = ['_' num2str(length(P(i).runs)) 'r-' num2str(P(i).runs(1)) '-' num2str(P(i).runs(end)) '_' DataHash(P(i).runs)];
                    %                     else
                    %                         run_string = ['_r' sprintf('%d',P(i).runs)];
                    %                     end
                    %                     lower_level_directory = [params('rootdir') 'freesurfer/fsaverage/tla_permutation/' subjid '/' P(i).runtype run_string '/' P(i).lower_level_directory_name '_downsampled/contrasts/'];
                end
                
                lower_level_cope_file = [lower_level_directory  'cope_' P(i).contrast '.mat'];
                lower_level_cope_var_file = [lower_level_directory 'cope_var_' P(i).contrast '.mat'];
                
                % load contrast values and variances for permuted condition orders
                load([lower_level_directory 'perm_condition_order_' num2str(n_perms) 'smps_' P(i).contrast '.mat'],'permuted_cope','permuted_cope_var','nonzero_voxels')
                
                
            otherwise
                error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
        end
        
        switch volume_or_surface
            
            case {'volume','surface'}
                % actual contrasts and variances
                x = MRIread(lower_level_cope_file);
                if i == 1
                    br = x;
                    n_voxels = numel(br.vol);
                    lower_level_cope = nan(n_subjects,n_voxels);
                    lower_level_cope_var = nan(n_subjects,n_voxels);
                    lower_level_df = nan(n_subjects,1);
                end
                lower_level_cope(i,:) = x.vol(:);
                x = MRIread(lower_level_cope_var_file);
                lower_level_cope_var(i,:) = x.vol(:);
                
                % degrees of freedom
                x = load([lower_level_directory 'df.mat']);
                lower_level_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_lower_level_cope = nan(n_perms,n_subjects,n_voxels);
                    permuted_lower_level_cope_var = nan(n_perms,n_subjects,n_voxels);
                end
                permuted_lower_level_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_lower_level_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            case 'downsampled_surface'
                
                % cope
                load(lower_level_cope_file);
                if i == 1
                    n_voxels = numel(G.grid_data{1}) + numel(G.grid_data{2});
                    lower_level_cope = nan(n_subjects,n_voxels);
                    lower_level_cope_var = nan(n_subjects,n_voxels);
                    lower_level_df = nan(n_subjects,1);
                end
                lower_level_cope(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % var cope
                load(lower_level_cope_var_file);
                lower_level_cope_var(i,:) = [G.grid_data{1}(:)', G.grid_data{2}(:)'];
                
                % degrees of freedom
                x = load([lower_level_directory 'df.mat']);
                lower_level_df(i) = x.df;
                
                % permuted contrasts and variances
                if i == 1
                    permuted_lower_level_cope = nan(n_perms,n_subjects,n_voxels);
                    permuted_lower_level_cope_var = nan(n_perms,n_subjects,n_voxels);
                end
                permuted_lower_level_cope(:,i,nonzero_voxels) = permuted_cope;
                permuted_lower_level_cope_var(:,i,nonzero_voxels) = permuted_cope_var;
                
            otherwise
                error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
        end
        
    end
    
    % convert copes to z-statistics
    lower_level_z = nan(size(lower_level_cope));
    xi = lower_level_cope ~= 0 & lower_level_cope_var ~=0;
    lower_level_z(xi) = lower_level_cope(xi) ./ sqrt(lower_level_cope_var(xi));
    
    % divide permutations by variances
    permuted_lower_level_z = nan(size(permuted_lower_level_cope));
    xi = ~isnan(permuted_lower_level_cope) & ~isnan(permuted_lower_level_cope_var);
    permuted_lower_level_z(xi) = permuted_lower_level_cope(xi) ./ sqrt(permuted_lower_level_cope_var(xi));
    
    % third-level, z-statistic
    zstat = mean(lower_level_z);
    
    fprintf('Selecting voxels without NaN values\n');
    tic;
    voxels_with_no_NaNs = squeeze(all(~isnan(permuted_lower_level_z(1,:,:)),2)) & ~isnan(zstat)';
    permuted_lower_level_z_with_noNaNs = permuted_lower_level_z(:,:,voxels_with_no_NaNs);
    tla_z_voxels_with_noNaNs = zstat(voxels_with_no_NaNs);
    toc;
        
    % p-values computed by comparing measured t-statistic with null distribution
    % computed in parallel when multiple cores are available
    fprintf('Calculating null distribution and p-statistics\n'); drawnow;
    tic;
    smps = randi(n_perms, [n_subjects, n_smps]);
    indices = smps + ((0:n_subjects-1)*n_perms)' * ones(1,n_smps);
    pstat_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    pstat_gaussfit_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    zstat_gaussfit_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    nullmean_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    nullstd_voxels_with_no_NaNs = nan(1,sum(voxels_with_no_NaNs));
    for i = 1:length(pstat_voxels_with_no_NaNs)
        
        % permuted z values for a single voxel
        % -> permutations x subject
        permuted_lower_level_z_single_voxel = permuted_lower_level_z_with_noNaNs(:,:,i);
        
        % average across permuted maps of different subjects
        % -> 1 x permutation
        permuted_tla_z = mean(permuted_lower_level_z_single_voxel(indices));
        
        % mean and standard deviation of the null
        nullmean_voxels_with_no_NaNs(i) = mean(permuted_tla_z);
        nullstd_voxels_with_no_NaNs(i) = std(permuted_tla_z);
        
        % z-statistic for unpermuted regressors with respect to the mean
        % and standard deviation of the null
        zstat_gaussfit_voxels_with_no_NaNs(i) = (tla_z_voxels_with_noNaNs(i) - nullmean_voxels_with_no_NaNs(i)) ./ nullstd_voxels_with_no_NaNs(i);
        
        % convert z-statistic to p value
        pstat_gaussfit_voxels_with_no_NaNs(i) = 2*normcdf(-abs(zstat_gaussfit_voxels_with_no_NaNs(i)), 0, 1);
        
        % measure empirical p-value via counts
        pstat_voxels_with_no_NaNs(i) = mean(abs(permuted_tla_z) > abs(tla_z_voxels_with_noNaNs(i))); % two-tailed
    end
    toc;
    
    % clean-up p-statistic vector
    pstat = nan(1,n_voxels);
    pstat(voxels_with_no_NaNs) = pstat_voxels_with_no_NaNs;
    pstat_gaussfit = nan(1,n_voxels);
    pstat_gaussfit(voxels_with_no_NaNs) = pstat_gaussfit_voxels_with_no_NaNs;
    zstat_gaussfit = nan(1,n_voxels);
    zstat_gaussfit(voxels_with_no_NaNs) = zstat_gaussfit_voxels_with_no_NaNs;
    nullmean = nan(1,n_voxels);
    nullmean(voxels_with_no_NaNs) = nullmean_voxels_with_no_NaNs;
    nullstd = nan(1,n_voxels);
    nullstd(voxels_with_no_NaNs) = nullstd_voxels_with_no_NaNs;
    
    % minimum p-value determined by the number of samples drawn
    pstat(pstat==0) = (1/n_smps);
    pstat_gaussfit(pstat_gaussfit==0) = min(pstat_gaussfit(pstat_gaussfit>0));
    
    % PDF and CDF of p-statistic
    figure;
    subplot(1,2,1);
    x = linspace(0,1,100);
    nx = hist(pstat(~isnan(pstat)),x);
    plot(x,nx/sum(nx));
    xlabel('P-Value'); ylabel('Proportion of Voxels');
    title('PDF of Permutation-Based P-values');
    subplot(1,2,2);
    plot(sort(pstat(~isnan(pstat))), cumsum(ones(1,length(pstat(~isnan(pstat)))))/length(pstat(~isnan(pstat))), 'k-','LineWidth',2); hold on;
    plot([0 1],[0 1],'r--','LineWidth',2);
    xlabel('P-Value'); ylabel('Cumulative Proportion of Voxels');
    title('CDF of Permutation-Based P-values');
    export_fig([tla_directory 'pstat_hist.pdf'],'-pdf','-transparent','-nocrop');
    
    switch volume_or_surface
        
        case {'volume','surface'}
            
            error('Need to setup volume/surface analysis');
            
        case 'downsampled_surface'
            
            % p-map file
            G.grid_data{1}(:) = sign(zstat(1:numel(G.grid_data{1}))) .* -log10(pstat(1:numel(G.grid_data{1})));
            G.grid_data{2}(:) = sign(zstat(numel(G.grid_data{1})+1:end)) .* -log10(pstat(numel(G.grid_data{1})+1:end));
            save(p_file, 'G');
            Gpstat = G;
                        
            % z-stat file
            G.grid_data{1}(:) = zstat(1:numel(G.grid_data{1}));
            G.grid_data{2}(:) = zstat(numel(G.grid_data{1})+1:end);
            save(z_file, 'G');
            
            % p-map based on gaussian fits file
            G.grid_data{1}(:) = sign(zstat_gaussfit(1:numel(G.grid_data{1}))) .* -log10(pstat_gaussfit(1:numel(G.grid_data{1})));
            G.grid_data{2}(:) = sign(zstat_gaussfit(numel(G.grid_data{1})+1:end)) .* -log10(pstat_gaussfit(numel(G.grid_data{1})+1:end));
            save(p_gaussfit_file, 'G');
            Gpstat_gaussfit = G;
                        
            % z-stat based on gaussian fits
            G.grid_data{1}(:) = zstat_gaussfit(1:numel(G.grid_data{1}));
            G.grid_data{2}(:) = zstat_gaussfit(numel(G.grid_data{1})+1:end);
            save(z_gaussfit_file, 'G');
            
            % p-map resampled to the inflated fsaverage brain
            hemis = {'rh','lh'};
            for j = 1:2
                p_inflated = nan(1, nsurfpts);
                p_gaussfit_inflated = nan(1, nsurfpts);
                p_inflated(G.vi{j}+1) = interp2(Gpstat.grid_x{j},Gpstat.grid_y{j} ,Gpstat.grid_data{j}, Gpstat.vras{j}(:,1), Gpstat.vras{j}(:,2), 'linear');
                p_gaussfit_inflated(G.vi{j}+1) = interp2(Gpstat_gaussfit.grid_x{j}, Gpstat_gaussfit.grid_y{j}, Gpstat_gaussfit.grid_data{j}, Gpstat_gaussfit.vras{j}(:,1), Gpstat_gaussfit.vras{j}(:,2),'linear');
                switch hemis{j}
                    case 'rh'
                        MRIwrite_surface(p_inflated, p_rh_inflated_file, 'rh');
                        MRIwrite_surface(p_gaussfit_inflated, p_gaussfit_rh_inflated_file, 'rh');
                    case 'lh'
                        MRIwrite_surface(p_inflated, p_lh_inflated_file, 'lh');
                        MRIwrite_surface(p_gaussfit_inflated, p_gaussfit_lh_inflated_file, 'lh');
                end
            end
            
        otherwise
            error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
    end
    
    save(mat_file_with_all_useful_statistics, 'zstat', 'pstat', 'pstat_gaussfit', 'zstat_gaussfit', 'nullmean', 'nullstd', 'permuted_lower_level_z_with_noNaNs', 'voxels_with_no_NaNs', 'smps')
    
end

keyboard;

% -- cluster correction --

% z-map threshold, which determines the cluster size
zthresh = 3;
if optInputs(varargin, 'zthresh')
    zthresh = varargin{optInputs(varargin, 'zthresh') + 1};
end

pthresh = 0.05;
if optInputs(varargin, 'pthresh')
    pthresh = varargin{optInputs(varargin, 'pthresh') + 1};
end

% output files
switch volume_or_surface
    case 'volume'
        
        error('Need to setup volume analysis');
        
    case 'surface'
        
        error('Need to setup surface analysis');
        
    case 'downsampled_surface'
        
        p_cluster_thresh_file =  [tla_directory  'pstat_permutation_' num2str(n_smps) '_cluster_corrected_z' num2str(zthresh) '_p' num2str(pthresh)  '.mat'];
        p_rh_inflated_cluster_thresh_file =  [tla_directory  'rh.pstat_permutation_' num2str(n_smps) '_cluster_corrected_z' num2str(zthresh) '_p' num2str(pthresh)  '.mgz'];
        p_lh_inflated_cluster_thresh_file =  [tla_directory  'lh.pstat_permutation_' num2str(n_smps) '_cluster_corrected_z' num2str(zthresh) '_p' num2str(pthresh)  '.mgz'];
        
    otherwise
        error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"...');
        
end

if optInputs(varargin, 'cluster-correction') && (optInputs(varargin, 'overwrite') || ~exist(p_cluster_thresh_file, 'file'))
    
    load(mat_file_with_all_useful_statistics, 'zstat', 'pstat', 'pstat_gaussfit', 'zstat_gaussfit', 'nullmean','nullstd', 'permuted_lower_level_z_with_noNaNs', 'voxels_with_no_NaNs', 'smps')
    load(p_file);
    
    % initialize variables
    n_subjects = size(permuted_lower_level_z_with_noNaNs,2);
    n_voxels = length(zstat);
    sampled_lower_level_zmap = nan(n_subjects, sum(voxels_with_no_NaNs));
    sampled_tla_zmap = nan(1, n_voxels);
    rh_grid = nan(size(G.grid_data{1}));
    lh_grid = nan(size(G.grid_data{2}));
    n_clusters = nan(1,n_smps);
    max_cluster_size = zeros(1,n_smps);
    
    fprintf('Cluster statistics for permuted z-maps\n');
    tic;
    for i = 1:n_smps
        
        % z-map for this set of samples
        for j = 1:n_subjects
            % select a single permuted map from one permuted model and subject
            % sample x subject x nvoxels
            sampled_lower_level_zmap(j,:) = permuted_lower_level_z_with_noNaNs( smps(j,i), j, :);
        end
        
        % average map across subjects
        % 1 x nvoxels
        sampled_tla_zmap(voxels_with_no_NaNs) = mean(sampled_lower_level_zmap);
        
        % convert to a true z-value based on gaussian fit to the null
        sampled_tla_zmap_gaussfit = (sampled_tla_zmap - nullmean) ./ nullstd;
        
        % grid z-map
        rh_grid(:) = sampled_tla_zmap_gaussfit(1:numel(rh_grid));
        lh_grid(:) = sampled_tla_zmap_gaussfit(numel(rh_grid)+1:end);
        
        % connected clusters
        comp_rh = bwconncomp(abs(rh_grid)>zthresh, 4);
        comp_lh = bwconncomp(abs(lh_grid)>zthresh, 4);
        n_clusters(i) = comp_rh.NumObjects + comp_lh.NumObjects;
        
        % maximum size of the clusters
        for j = 1:comp_rh.NumObjects
            max_cluster_size(i) = max(max_cluster_size(i), length(comp_rh.PixelIdxList{j}));
        end
        
        % maximum size of the clusters
        for j = 1:comp_lh.NumObjects
            max_cluster_size(i) = max(max_cluster_size(i), length(comp_lh.PixelIdxList{j}));
        end
        
    end
    toc;
    
    % cluster statistic
    sorted_cluster_sizes = sort(max_cluster_size,'descend');
    cluster_size_thresh = round(interp1( log2((1:n_smps)/n_smps), sorted_cluster_sizes, log2(pthresh)));
    
    % right-hemisphere mask
    rh_grid(:) = zstat_gaussfit(1:numel(rh_grid));
    comp_rh = bwconncomp(abs(rh_grid)>zthresh, 4);
    rh_mask = zeros(size(rh_grid));
    for j = 1:comp_rh.NumObjects
        if length(comp_rh.PixelIdxList{j}) > cluster_size_thresh
            rh_mask(comp_rh.PixelIdxList{j}) = 1;
            fprintf('Right hemisphere cluster %d of size %d is above the cluster threshold of %d voxels\n', j, length(comp_rh.PixelIdxList{j}), cluster_size_thresh);
        else
            fprintf('Right hemisphere cluster %d of size %d is below the cluster threshold of %d voxels\n', j, length(comp_rh.PixelIdxList{j}), cluster_size_thresh);
        end
    end
    
    % left-hemisphere mask
    lh_grid(:) = zstat_gaussfit(numel(rh_grid)+1:end);
    comp_lh = bwconncomp(abs(lh_grid)>zthresh, 4);
    lh_mask = zeros(size(lh_grid));
    for j = 1:comp_lh.NumObjects
        if length(comp_lh.PixelIdxList{j}) > cluster_size_thresh
            lh_mask(comp_lh.PixelIdxList{j}) = 1;
            fprintf('Left hemisphere cluster %d of size %d is above the cluster threshold of %d voxels\n', j, length(comp_lh.PixelIdxList{j}), cluster_size_thresh);
        else
            fprintf('Left hemisphere cluster %d of size %d is below the cluster threshold of %d voxels\n', j, length(comp_lh.PixelIdxList{j}), cluster_size_thresh);
        end
    end
    
    switch volume_or_surface
        
        case {'volume','surface'}
            
            error('Need to setup volume/surface analysis');
            
        case 'downsampled_surface'
                        
            % save thresholded the p-value map with the mask
            load(p_gaussfit_file);
            G.grid_data{1}(~rh_mask) = 0;
            G.grid_data{2}(~lh_mask) = 0;
            save(p_cluster_thresh_file, 'G');
            
            % resample the mask to the inflated surface and use to
            % threshold the
            hemis = {'rh','lh'};
            for j = 1:2
                mask_inflated = nan(1, nsurfpts);
                z_inflated = nan(1, nsurfpts);
                switch hemis{j}
                    case 'rh'
                        z_grid = rh_grid;
                        z_grid(:) = zstat_gaussfit(1:numel(rh_grid));
                        z_inflated(G.vi{j}+1) = interp2(G.grid_x{j},G.grid_y{j},z_grid,G.vras{j}(:,1),G.vras{j}(:,2),'cubic');
                        mask_inflated(G.vi{j}+1) = interp2(G.grid_x{j},G.grid_y{j},rh_mask,G.vras{j}(:,1),G.vras{j}(:,2),'cubic');
                        x = MRIread(p_gaussfit_rh_inflated_file);
                        p_inflated_cluster_corrected = x.vol(:);
                        p_inflated_cluster_corrected(~(mask_inflated > 0.1 & z_inflated > zthresh)) = 0;
                        MRIwrite_surface(p_inflated_cluster_corrected, p_rh_inflated_cluster_thresh_file, 'rh');
                    case 'lh'
                        z_grid = lh_grid;
                        z_grid(:) = zstat_gaussfit(numel(rh_grid)+1:end);
                        z_inflated(G.vi{j}+1) = interp2(G.grid_x{j},G.grid_y{j},z_grid,G.vras{j}(:,1),G.vras{j}(:,2),'cubic');
                        mask_inflated(G.vi{j}+1) = interp2(G.grid_x{j},G.grid_y{j},lh_mask,G.vras{j}(:,1),G.vras{j}(:,2),'cubic');
                        x = MRIread(p_gaussfit_lh_inflated_file);
                        p_inflated_cluster_corrected = x.vol(:);
                        p_inflated_cluster_corrected(~(mask_inflated > 0.1 & z_inflated > zthresh)) = 0;
                        MRIwrite_surface(p_inflated_cluster_corrected, p_lh_inflated_cluster_thresh_file, 'lh');
                end
            end
            
        otherwise
            error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface" or "downsampled_surface"');
    end
    
    save(mat_file_with_all_useful_statistics, 'zstat', 'pstat',  'pstat_gaussfit', 'zstat_gaussfit', 'nullmean','nullstd', 'permuted_lower_level_z_with_noNaNs', 'voxels_with_no_NaNs', 'smps', 'cluster_size_thresh', 'sorted_cluster_sizes', 'rh_mask', 'lh_mask');
    
end

load(mat_file_with_all_useful_statistics, 'zstat', 'pstat',  'pstat_gaussfit', 'zstat_gaussfit', 'nullmean','nullstd', 'permuted_lower_level_z_with_noNaNs', 'voxels_with_no_NaNs', 'smps', 'cluster_size_thresh', 'sorted_cluster_sizes', 'rh_mask', 'lh_mask');

% p-statistic vs z-statistic
% useful to pick cluster threshold
figure;
plot(sign(zstat_gaussfit(voxels_with_no_NaNs)) .* -log10(pstat_gaussfit(voxels_with_no_NaNs)), zstat_gaussfit(voxels_with_no_NaNs), 'ko');
ylabel('z-statistic'); xlabel('p-statistic (-log10[p])');
xL = xlim;
hold on; h = plot(xL, zthresh*[1 1], 'r--');
box off;
legend(h, 'Cluster Z-Threshold', 'Location', 'Best');
export_fig([tla_directory 'z-vs-p.pdf'],'-pdf','-transparent');

% plot cluster threshold vs. p-value threshold
figure;
plot(-log10((1:n_smps)/n_smps), sorted_cluster_sizes, 'k-', 'LineWidth',2);
hold on;
plot(-log10(pthresh), cluster_size_thresh, 'ro', 'LineWidth', 2);
xlabel('p-threshold (-log10[p])'); ylabel('Cluster Size');
title(sprintf('Cluster-threshold: %d voxels', cluster_size_thresh));
fprintf('Cluster size threshold is %d voxels\n', cluster_size_thresh);
export_fig([tla_directory 'cluster-size-vs-p.pdf'],'-pdf','-transparent');

% compare p-statistics based on gaussian fits with the p-statistics based
% on counts
figure;
log10pstat = sign(zstat(voxels_with_no_NaNs)) .* -log10(pstat(voxels_with_no_NaNs));
log10pstat_gaussfit = sign(zstat_gaussfit(voxels_with_no_NaNs)) .* -log10(pstat_gaussfit(voxels_with_no_NaNs));
plot(log10pstat, log10pstat_gaussfit, 'ko');
xlabel('p-statistic (-log10[p])'); ylabel('gaussian-approximated p-statistic (-log10[p])');
bounds = [min(log10pstat_gaussfit(:)), max(log10pstat_gaussfit(:))];
xlim(bounds); ylim(bounds);
x = linspace(bounds(1),bounds(2),100);
hold on; plot(x,x,'r--');
box off;
export_fig([tla_directory 'p-gaussfit-vs-p-count.pdf'],'-pdf','-transparent');

% -- plot statistic --

if optInputs(varargin, 'sigmap')
    switch volume_or_surface
        case 'volume'
            
            error('Need to setup volume analysis');
            
        case 'surface'
            
            error('Need to setup surface analysis');
            
        case 'downsampled_surface'
            
            % plot p map on the downsampled surface
            load(p_gaussfit_file);
            figure;
            subplot(1,2,1);
            imagesc(flipud(rot90(G.grid_data{1})), [-6 6]);
            title('Right Hemi');
            subplot(1,2,2);
            imagesc(fliplr(flipud(rot90(G.grid_data{2}))), [-6 6]); %#ok<FLUDLR>
            title('Left Hemi');
            colorbar;
            
            % plot map on the surface
            if optInputs(varargin, 'cluster-correction')
                freeview3('fsaverage','rh','overlay',p_rh_inflated_cluster_thresh_file, 'overlay_threshold', [3 4.5 6]);
                freeview3('fsaverage','lh','overlay',p_lh_inflated_cluster_thresh_file, 'overlay_threshold', [3 4.5 6]);
            else
                % plot map on the inflated fsaverage brain
                freeview3('fsaverage','rh','overlay',p_gaussfit_rh_inflated_file, 'overlay_threshold', [3 4.5 6]);
                freeview3('fsaverage','lh','overlay',p_gaussfit_lh_inflated_file, 'overlay_threshold', [3 4.5 6]);
            end
            
        otherwise
            error('Error in tla_permutation: volume_or_surface flag must be either "volume", "surface", or "downsampled_surface"');
    end
end
